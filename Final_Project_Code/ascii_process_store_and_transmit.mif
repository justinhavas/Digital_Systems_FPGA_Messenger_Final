-- null
DEPTH = 4096;
WIDTH = 32;

ADDRESS_RADIX = DEC;
DATA_RADIX = BIN;

CONTENT
BEGIN
    -- addi $r16, $r0, 0
0000 : 00101100000000000000000000000000;
    -- addi $r17, $r0, 1
0001 : 00101100010000000000000000000001;
    -- addi $r20, $r0, 63 # x-limit
0002 : 00101101000000000000000000111111;
    -- addi $r21, $r0, 47 # y-limit
0003 : 00101101010000000000000000101111;
    -- addi $r15, $r0, 0
0004 : 00101011110000000000000000000000;
    -- bne $r15, $r0, 2 #r15 is ready register
0005 : 00010011110000000000000000000010;
    -- chReady #READ in Ascii and put in reg15 NEW INSTRUCTION, needs to write into register from line
0006 : 01001000000000000000000000000000;
    -- j 5 # change to bne expression
0007 : 00001000000000000000000000000101;
    -- chEnter #write value into reg14 NEW INSTRUCTION, needs to write into register from a line
0008 : 01010000000000000000000000000000;
    -- bne $r14, $r0, 36 # if an enter signal will do differently 
0009 : 00010011100000000000000000100100;
    -- addi $r16, $r16, 1 # x-coordinate
0010 : 00101100001000000000000000000001;
    -- blt $r20, $r16, 5 # check if x-coordinate off screen FIX THIS
0011 : 00110101001000000000000000000101;
    -- outCor $r16, $r17 # output x and y-coordinate NEW INSTRUCTION reading from reg and outputs in execute
0012 : 01011100001000100000000000000000;
    -- jal 23
0013 : 00011000000000000000000000010111;
    -- resReady # NEW INSTRUCTION opcode and all zeroes, check opcode in execute
0014 : 01100000000000000000000000000000;
    -- addi $r15, $r0, 0
0015 : 00101011110000000000000000000000;
    -- j 5
0016 : 00001000000000000000000000000101;
    -- addi $r16, $r0, 1
0017 : 00101100000000000000000000000001;
    -- addi $r17, $r17, 1 # y-coordinate add to y
0018 : 00101100011000100000000000000001;
    -- blt $r21, $r17, 1
0019 : 00110101011000100000000000000001;
    -- j 12 # go output new values
0020 : 00001000000000000000000000001100;
    -- addi $r17, $r0, 1 # this is at weird edge not sure what to do yet
0021 : 00101100010000000000000000000001;
    -- j 12 ###  to new code
0022 : 00001000000000000000000000001100;
    -- # custom load ascii into reg 25
0023 : 01101000000000000000000000000000;
    -- addi $r28, $r0, 1 # for calculating if at first byte of address
0024 : 00101111000000000000000000000001;
    -- sub $r28, $r28, $r22
0025 : 00000111001110010110000000000100;
    -- blt $r0, $r28, 10 # if not at first term in block, don't lw
0026 : 00110000001110000000000000001010;
    -- lw $r24, 0($r23) # load characters stored at the address
0027 : 01000110001011100000000000000000;
    -- addi $r28, $r0, 2 
0028 : 00101111000000000000000000000010;
    -- blt $r28, $r22, 11 # if at end of word
0029 : 00110111001011000000000000001011;
    -- addi $r28, $r0, 1
0030 : 00101111000000000000000000000001;
    -- blt $r28, $r22, 7
0031 : 00110111001011000000000000000111;
    -- sll $r25, $r25, 16 # shift if at position 1
0032 : 00000110011100100000100000010000;
    -- or $r24, $r24, $r25 
0033 : 00000110001100011001000000001100;
    -- sw $r24, 0($r23) # sw instructin with new ascii
0034 : 00111110001011100000000000000000;
    -- addi $r22, $r22, 1 # this is counter
0035 : 00101101101011000000000000000001;
    -- jr $r31 
0036 : 00100111110000000000000000000000;
    -- sll $r24, $r25, 24 # shift for position 0
0037 : 00000110001100100000110000010000;
    -- j 34
0038 : 00001000000000000000000000100010;
    -- sll $r25, $r25, 8 # shift for position 2
0039 : 00000110011100100000010000010000;
    -- j 33 
0040 : 00001000000000000000000000100001;
    -- or $r24, $r24, $r25 
0041 : 00000110001100011001000000001100;
    -- sw $r24, 0($r23) 
0042 : 00111110001011100000000000000000;
    -- addi $r22, $r0, 0
0043 : 00101101100000000000000000000000;
    -- addi $r23, $r23, 1 # this will hold the reg address
0044 : 00101101111011100000000000000001;
    -- jr $r31 ##### dealing with enter signals from wayyyy earlier
0045 : 00100111110000000000000000000000;
    -- jal 23
0046 : 00011000000000000000000000010111;
    -- addi $r16, $r0, 0
0047 : 00101100000000000000000000000000;
    -- addi $r17, $r17, 1 # y-coordinate add to y
0048 : 00101100011000100000000000000001;
    -- blt $r21, $r17, 3
0049 : 00110101011000100000000000000011;
    -- noop #jal autocorrect
0050 : 00000000000000000000000000000000;
    -- jal transmit
0051 : 00011000000000000000000000111001;
    -- j 14 # go store enter
0052 : 00001000000000000000000000001110;
    -- addi $r17, $r0, 1 #ADD AUTO CORRECT HERE
0053 : 00101100010000000000000000000001;
    -- noop #jal autocorrect
0054 : 00000000000000000000000000000000;
    -- jal transmit
0055 : 00011000000000000000000000111001;
    -- j 14 #### start transmitting
0056 : 00001000000000000000000000001110;
    -- transmit: nop
0057 : 00000000000000000000000000000000;
    -- bne $r18, $r0, 2 # make sure to pass in the negative of transmitting signal as notifyer 
0058 : 00010100100000000000000000000010;
    -- chTransmit # that goes to $r18, 
0059 : 01110000000000000000000000000000;
    -- j transmit
0060 : 00001000000000000000000000111001;
    -- addi $r29, $r0, 10 
0061 : 00101111010000000000000000001010;
    -- addi $r19, $r0, 0
0062 : 00101100110000000000000000000000;
    -- lw $r24, 0($r27)
0063 : 01000110001101100000000000000000;
    -- addi $r28, $r0, 2 
0064 : 00101111000000000000000000000010;
    -- blt $r28, $r26, 25 # check if at end of word
0065 : 00110111001101000000000000011001;
    -- addi $r28, $r0, 1 
0066 : 00101111000000000000000000000001;
    -- blt $r28, $r26, 18 # check if pos 2
0067 : 00110111001101000000000000010010;
    -- addi $r28, $r0, 0 
0068 : 00101111000000000000000000000000;
    -- blt $r28, $r26, 11 # check if pos 1
0069 : 00110111001101000000000000001011;
    -- addi $r28, $r0, 255 # at this point, in zero pos
0070 : 00101111000000000000000011111111;
    -- sll $r28, $r28, 24 # shift if at position 0
0071 : 00000111001110000000110000010000;
    -- and $r28, $r28, $r24 # these pull out digits wanted
0072 : 00000111001110011000000000001000;
    -- addi $r19, $r0, 1
0073 : 00101100110000000000000000000001;
    -- bne $r19, $r0, 21
0074 : 00010100110000000000000000010101;
    -- outTrasmit # which outputs to special register 28, 
0075 : 01111000000000000000000000000000;
    -- addi $r26, $r26, 1 # address of subaddress, r27 holds the address
0076 : 00101110101101000000000000000001;
    -- j waitTransmit 
0077 : 00001000000000000000000001100010;
    -- bne $r28, $r29, 1 # see if enter is outputted
0078 : 00010111001110100000000000000001;
    -- jr $r31
0079 : 00100111110000000000000000000000;
    -- j transmit 
0080 : 00001000000000000000000000111001;
    -- addi $r28, $r0, 255
0081 : 00101111000000000000000011111111;
    -- sll $r28, $r28, 16 # shift if at position 1
0082 : 00000111001110000000100000010000;
    -- and $r28, $r28, $r24
0083 : 00000111001110011000000000001000;
    -- sra $r28, $r28, 16
0084 : 00000111001110000000100000010100;
    -- j 75
0085 : 00001000000000000000000001001011;
    -- addi $r28, $r0, 255
0086 : 00101111000000000000000011111111;
    -- sll $r28, $r28, 8 # shift if at position 2
0087 : 00000111001110000000010000010000;
    -- and $r28, $r28, $r24
0088 : 00000111001110011000000000001000;
    -- sra $r28, $r28, 8
0089 : 00000111001110000000010000010100;
    -- j 75
0090 : 00001000000000000000000001001011;
    -- addi $r28, $r0, 255
0091 : 00101111000000000000000011111111;
    -- and $r28, $r28, $r24 # at end of word
0092 : 00000111001110011000000000001000;
    -- addi $r26, $r0, -1
0093 : 00101110100000011111111111111111;
    -- addi $r27, $r27, 1
0094 : 00101110111101100000000000000001;
    -- j 75
0095 : 00001000000000000000000001001011;
    -- sra $r28, $r28, 24
0096 : 00000111001110000000110000010100;
    -- j 75
0097 : 00001000000000000000000001001011;
    -- waitTransmit: nop
0098 : 00000000000000000000000000000000;
    -- addi $r19, $r0, 1
0099 : 00101100110000000000000000000001;
    -- blt $r18, $r19, 2 # wait until transmit ready is 0 
0100 : 00110100101001100000000000000010;
    -- chTransmit #that goes to $r18, ADD EXTRA LOGIC like the press down so flag not turned on
0101 : 01110000000000000000000000000000;
    -- j waitTransmit
0102 : 00001000000000000000000001100010;
    -- addi $r18, $r0, 0 
0103 : 00101100100000000000000000000000;
    -- j 78
0104 : 00001000000000000000000001001110;
[0105 .. 4095] : 00000000000000000000000000000000;
END;
