-- null
DEPTH = 4096;
WIDTH = 32;

ADDRESS_RADIX = DEC;
DATA_RADIX = BIN;

CONTENT
BEGIN
    -- addi $r16, $r0, 0
0000 : 00101100000000000000000000000000;
    -- addi $r17, $r0, 1
0001 : 00101100010000000000000000000001;
    -- addi $r20, $r0, 63 # x-limit
0002 : 00101101000000000000000000111111;
    -- addi $r21, $r0, 47 # y-limit
0003 : 00101101010000000000000000101111;
    -- addi $r15, $r0, 0
0004 : 00101011110000000000000000000000;
    -- chReady #READ in Ascii and put in reg15 NEW INSTRUCTION, needs to write into register from line
0005 : 01001000000000000000000000000000;
    -- bne $r15, $r0, 3 #r15 is ready register
0006 : 00010011110000000000000000000011;
    -- chReceiving # CUSTOM instruction to see if receiving data to reg 19
0007 : 10000000000000000000000000000000;
    -- bne $r19, $r0, receiving
0008 : 00010100110000000000000001100011;
    -- j 5 # change to bne expression
0009 : 00001000000000000000000000000101;
    -- chEnter #write value into reg14 NEW INSTRUCTION, needs to write into register from a line
0010 : 01010000000000000000000000000000;
    -- bne $r14, $r0, 36 # if an enter signal will do differently 
0011 : 00010011100000000000000000100100;
    -- addi $r16, $r16, 1 # x-coordinate
0012 : 00101100001000000000000000000001;
    -- blt $r20, $r16, 5 # check if x-coordinate off screen FIX THIS
0013 : 00110101001000000000000000000101;
    -- outCor $r16, $r17 # output x and y-coordinate NEW INSTRUCTION reading from reg and outputs in execute
0014 : 01011100001000100000000000000000;
    -- jal 25
0015 : 00011000000000000000000000011001;
    -- resReady # NEW INSTRUCTION opcode and all zeroes, check opcode in execute
0016 : 01100000000000000000000000000000;
    -- addi $r15, $r0, 0
0017 : 00101011110000000000000000000000;
    -- j 5
0018 : 00001000000000000000000000000101;
    -- addi $r16, $r0, 1
0019 : 00101100000000000000000000000001;
    -- addi $r17, $r17, 1 # y-coordinate add to y
0020 : 00101100011000100000000000000001;
    -- blt $r21, $r17, 1
0021 : 00110101011000100000000000000001;
    -- j 14 # go output new values
0022 : 00001000000000000000000000001110;
    -- addi $r17, $r0, 1 # this is at weird edge not sure what to do yet
0023 : 00101100010000000000000000000001;
    -- j 14 ###  to new code
0024 : 00001000000000000000000000001110;
    -- custom load ascii into reg 25
0025 : 01101000000000000000000000000000;
    -- addi $r28, $r0, 1 # for calculating if at first byte of address
0026 : 00101111000000000000000000000001;
    -- sub $r28, $r28, $r22
0027 : 00000111001110010110000000000100;
    -- blt $r0, $r28, 10 # if not at first term in block, don't lw
0028 : 00110000001110000000000000001010;
    -- lw $r24, 0($r23) # load characters stored at the address
0029 : 01000110001011100000000000000000;
    -- addi $r28, $r0, 2 
0030 : 00101111000000000000000000000010;
    -- blt $r28, $r22, 11 # if at end of word
0031 : 00110111001011000000000000001011;
    -- addi $r28, $r0, 1
0032 : 00101111000000000000000000000001;
    -- blt $r28, $r22, 7
0033 : 00110111001011000000000000000111;
    -- sll $r25, $r25, 16 # shift if at position 1
0034 : 00000110011100100000100000010000;
    -- or $r24, $r24, $r25 
0035 : 00000110001100011001000000001100;
    -- sw $r24, 0($r23) # sw instructin with new ascii
0036 : 00111110001011100000000000000000;
    -- addi $r22, $r22, 1 # this is counter
0037 : 00101101101011000000000000000001;
    -- jr $r31 
0038 : 00100111110000000000000000000000;
    -- sll $r24, $r25, 24 # shift for position 0
0039 : 00000110001100100000110000010000;
    -- j 36
0040 : 00001000000000000000000000100100;
    -- sll $r25, $r25, 8 # shift for position 2
0041 : 00000110011100100000010000010000;
    -- j 35 
0042 : 00001000000000000000000000100011;
    -- or $r24, $r24, $r25 
0043 : 00000110001100011001000000001100;
    -- sw $r24, 0($r23) 
0044 : 00111110001011100000000000000000;
    -- addi $r22, $r0, 0
0045 : 00101101100000000000000000000000;
    -- addi $r23, $r23, 1 # this will hold the reg address
0046 : 00101101111011100000000000000001;
    -- jr $r31 ##### dealing with enter signals from wayyyy earlier
0047 : 00100111110000000000000000000000;
    -- jal 25
0048 : 00011000000000000000000000011001;
    -- addi $r16, $r0, 0
0049 : 00101100000000000000000000000000;
    -- addi $r17, $r17, 1 # y-coordinate add to y
0050 : 00101100011000100000000000000001;
    -- blt $r21, $r17, 3
0051 : 00110101011000100000000000000011;
    -- noop #jal autocorrect
0052 : 00000000000000000000000000000000;
    -- jal transmit
0053 : 00011000000000000000000000111011;
    -- j 16 # go store enter
0054 : 00001000000000000000000000010000;
    -- addi $r17, $r0, 1 #ADD AUTO CORRECT HERE
0055 : 00101100010000000000000000000001;
    -- noop #jal autocorrect
0056 : 00000000000000000000000000000000;
    -- jal transmit
0057 : 00011000000000000000000000111011;
    -- j 16 #### start transmitting
0058 : 00001000000000000000000000010000;
    -- transmit: nop
0059 : 00000000000000000000000000000000;
    -- bne $r18, $r0, 2 # make sure to pass in the negative of transmitting signal as notifyer 
0060 : 00010100100000000000000000000010;
    -- chTransmit # that goes to $r18, 
0061 : 01110000000000000000000000000000;
    -- j transmit
0062 : 00001000000000000000000000111011;
    -- addi $r29, $r0, 10 
0063 : 00101111010000000000000000001010;
    -- addi $r19, $r0, 0
0064 : 00101100110000000000000000000000;
    -- lw $r24, 0($r27)
0065 : 01000110001101100000000000000000;
    -- addi $r28, $r0, 2 
0066 : 00101111000000000000000000000010;
    -- blt $r28, $r26, 25 # check if at end of word
0067 : 00110111001101000000000000011001;
    -- addi $r28, $r0, 1 
0068 : 00101111000000000000000000000001;
    -- blt $r28, $r26, 18 # check if pos 2
0069 : 00110111001101000000000000010010;
    -- addi $r28, $r0, 0 
0070 : 00101111000000000000000000000000;
    -- blt $r28, $r26, 11 # check if pos 1
0071 : 00110111001101000000000000001011;
    -- addi $r28, $r0, 255 # at this point, in zero pos
0072 : 00101111000000000000000011111111;
    -- sll $r28, $r28, 24 # shift if at position 0
0073 : 00000111001110000000110000010000;
    -- and $r28, $r28, $r24 # these pull out digits wanted
0074 : 00000111001110011000000000001000;
    -- addi $r19, $r0, 1
0075 : 00101100110000000000000000000001;
    -- bne $r19, $r0, 21
0076 : 00010100110000000000000000010101;
    -- outTrasmit # which outputs to special register 28, 
0077 : 01111000000000000000000000000000;
    -- addi $r26, $r26, 1 # address of subaddress, r27 holds the address
0078 : 00101110101101000000000000000001;
    -- j waitTransmit 
0079 : 00001000000000000000000001100100;
    -- bne $r28, $r29, 1 # see if enter is outputted
0080 : 00010111001110100000000000000001;
    -- jr $r31
0081 : 00100111110000000000000000000000;
    -- j transmit 
0082 : 00001000000000000000000000111011;
    -- addi $r28, $r0, 255
0083 : 00101111000000000000000011111111;
    -- sll $r28, $r28, 16 # shift if at position 1
0084 : 00000111001110000000100000010000;
    -- and $r28, $r28, $r24
0085 : 00000111001110011000000000001000;
    -- sra $r28, $r28, 16
0086 : 00000111001110000000100000010100;
    -- j 77
0087 : 00001000000000000000000001001101;
    -- addi $r28, $r0, 255
0088 : 00101111000000000000000011111111;
    -- sll $r28, $r28, 8 # shift if at position 2
0089 : 00000111001110000000010000010000;
    -- and $r28, $r28, $r24
0090 : 00000111001110011000000000001000;
    -- sra $r28, $r28, 8
0091 : 00000111001110000000010000010100;
    -- j 77
0092 : 00001000000000000000000001001101;
    -- addi $r28, $r0, 255
0093 : 00101111000000000000000011111111;
    -- and $r28, $r28, $r24 # at end of word
0094 : 00000111001110011000000000001000;
    -- addi $r26, $r0, -1
0095 : 00101110100000011111111111111111;
    -- addi $r27, $r27, 1
0096 : 00101110111101100000000000000001;
    -- j 77
0097 : 00001000000000000000000001001101;
    -- sra $r28, $r28, 24
0098 : 00000111001110000000110000010100;
    -- j 77
0099 : 00001000000000000000000001001101;
    -- waitTransmit: nop
0100 : 00000000000000000000000000000000;
    -- addi $r19, $r0, 1
0101 : 00101100110000000000000000000001;
    -- blt $r18, $r19, 2 # wait until transmit ready is 0 
0102 : 00110100101001100000000000000010;
    -- chTransmit #that goes to $r18, ADD EXTRA LOGIC like the press down so flag not turned on
0103 : 01110000000000000000000000000000;
    -- j waitTransmit
0104 : 00001000000000000000000001100100;
    -- addi $r18, $r0, 0 
0105 : 00101100100000000000000000000000;
    -- addi $r19, $r0, 0
0106 : 00101100110000000000000000000000;
    -- j 80
0107 : 00001000000000000000000001010000;
    -- receiving: nop
0108 : 00000000000000000000000000000000;
    -- addi $r29, $r0, 10
0109 : 00101111010000000000000000001010;
    -- chReceivingCharacter another NEW instruction into reg 28
0110 : 10001000000000000000000000000000;
    -- bne $r28, $r29, 2
0111 : 00010111001110100000000000000010;
    -- addi $r16, $r0, 0
0112 : 00101100000000000000000000000000;
    -- addi $r17, $r17, 1
0113 : 00101100011000100000000000000001;
    -- addi $r29, $r0, 1
0114 : 00101111010000000000000000000001;
    -- chReceiving which updates register 19
0115 : 10000000000000000000000000000000;
    -- blt $r19, $r29, 1 # wait until receiving ready is 0
0116 : 00110100111110100000000000000001;
    -- j 115
0117 : 00001000000000000000000001110011;
    -- addi $r19, $r0, 0
0118 : 00101100110000000000000000000000;
    -- j 5
0119 : 00001000000000000000000000000101;
[0120 .. 4095] : 00000000000000000000000000000000;
END;
